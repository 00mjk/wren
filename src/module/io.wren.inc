// Generated automatically from src/module/io.wren. Do not edit.
static const char* ioModuleSource =
"import \"scheduler\" for Scheduler\n"
"\n"
"class Directory {\n"
"  static def list(path) {\n"
"    if (!(path is String)) Fiber.abort(\"Path must be a string.\")\n"
"\n"
"    list_(path, Fiber.current)\n"
"    return Scheduler.runNextScheduled_()\n"
"  }\n"
"\n"
"  foreign static def list_(path, fiber)\n"
"}\n"
"\n"
"foreign class File {\n"
"  static def open(path) {\n"
"    if (!(path is String)) Fiber.abort(\"Path must be a string.\")\n"
"\n"
"    open_(path, Fiber.current)\n"
"    var fd = Scheduler.runNextScheduled_()\n"
"    return new_(fd)\n"
"  }\n"
"\n"
"  static def open(path, fn) {\n"
"    var file = open(path)\n"
"    var fiber = Fiber.new { fn.call(file) }\n"
"\n"
"    // Poor man's finally. Can we make this more elegant?\n"
"    var result = fiber.try()\n"
"    file.close()\n"
"\n"
"    // TODO: Want something like rethrow since now the callstack ends here. :(\n"
"    if (fiber.error != null) Fiber.abort(fiber.error)\n"
"    return result\n"
"  }\n"
"\n"
"  static def read(path) {\n"
"    return File.open(path) {|file| file.readBytes(file.size) }\n"
"  }\n"
"\n"
"  static def size(path) {\n"
"    if (!(path is String)) Fiber.abort(\"Path must be a string.\")\n"
"\n"
"    sizePath_(path, Fiber.current)\n"
"    return Scheduler.runNextScheduled_()\n"
"  }\n"
"\n"
"  static def stat(path) {\n"
"    if (!(path is String)) Fiber.abort(\"Path must be a string.\")\n"
"\n"
"    statPath_(path, Fiber.current)\n"
"    return Stat.new_(Scheduler.runNextScheduled_())\n"
"  }\n"
"\n"
"  construct new_(fd) {}\n"
"\n"
"  def close() {\n"
"    if (close_(Fiber.current)) return\n"
"    Scheduler.runNextScheduled_()\n"
"  }\n"
"\n"
"  foreign def descriptor\n"
"\n"
"  def isOpen { descriptor != -1 }\n"
"\n"
"  def size {\n"
"    if (!isOpen) Fiber.abort(\"File is not open.\")\n"
"\n"
"    size_(Fiber.current)\n"
"    return Scheduler.runNextScheduled_()\n"
"  }\n"
"\n"
"  def readBytes(count) { readBytes(count, 0) }\n"
"\n"
"  def readBytes(count, offset) {\n"
"    if (!isOpen) Fiber.abort(\"File is not open.\")\n"
"    if (!(count is Num)) Fiber.abort(\"Count must be an integer.\")\n"
"    if (!count.isInteger) Fiber.abort(\"Count must be an integer.\")\n"
"    if (count < 0) Fiber.abort(\"Count cannot be negative.\")\n"
"\n"
"    if (!(offset is Num)) Fiber.abort(\"Offset must be an integer.\")\n"
"    if (!offset.isInteger) Fiber.abort(\"Offset must be an integer.\")\n"
"    if (offset < 0) Fiber.abort(\"Offset cannot be negative.\")\n"
"\n"
"    readBytes_(count, offset, Fiber.current)\n"
"    return Scheduler.runNextScheduled_()\n"
"  }\n"
"\n"
"  foreign static def open_(path, fiber)\n"
"  foreign static def sizePath_(path, fiber)\n"
"  foreign static def statPath_(path, fiber)\n"
"\n"
"  foreign def close_(fiber)\n"
"  foreign def readBytes_(count, start, fiber)\n"
"  foreign def size_(fiber)\n"
"}\n"
"\n"
"class Stat {\n"
"  construct new_(fields) {\n"
"    _fields = fields\n"
"  }\n"
"\n"
"  def device { _fields[0] }\n"
"  def inode { _fields[1] }\n"
"  def mode { _fields[2] }\n"
"  def linkCount { _fields[3] }\n"
"  def user { _fields[4] }\n"
"  def group { _fields[5] }\n"
"  def specialDevice { _fields[6] }\n"
"  def size { _fields[7] }\n"
"  def blockSize { _fields[8] }\n"
"  def blockCount { _fields[9] }\n"
"}\n"
"\n"
"class Stdin {\n"
"  static def readLine() {\n"
"    if (__isClosed == true) {\n"
"      Fiber.abort(\"Stdin was closed.\")\n"
"    }\n"
"\n"
"    // TODO: Error if other fiber is already waiting.\n"
"    readStart_()\n"
"\n"
"    __waitingFiber = Fiber.current\n"
"    var line = Scheduler.runNextScheduled_()\n"
"\n"
"    readStop_()\n"
"    return line\n"
"  }\n"
"\n"
"  static def onData_(data) {\n"
"    if (data == null) {\n"
"      __isClosed = true\n"
"      readStop_()\n"
"\n"
"      if (__line != null) {\n"
"        // Emit the last line.\n"
"        var line = __line\n"
"        __line = null\n"
"        if (__waitingFiber != null) __waitingFiber.transfer(line)\n"
"      } else {\n"
"        __waitingFiber.transferError(\"Stdin was closed.\")\n"
"      }\n"
"    }\n"
"\n"
"    // TODO: Handle Windows line separators.\n"
"    var lineSeparator = data.indexOf(\"\n\")\n"
"\n"
"    if (__line == null) __line = \"\"\n"
"    if (lineSeparator == -1) {\n"
"      // No end of line yet, so just accumulate it.\n"
"      __line = __line + data\n"
"    } else {\n"
"      // Split the line at the separator.\n"
"      var line = __line + data[0...lineSeparator]\n"
"      if (lineSeparator > 0 && lineSeparator < data.count - 1) {\n"
"        // Buffer up the characters after the separator for the next line.\n"
"        __line = data[lineSeparator + 1..-1]\n"
"      } else {\n"
"        __line = \"\"\n"
"      }\n"
"\n"
"      if (__waitingFiber != null) __waitingFiber.transfer(line)\n"
"    }\n"
"  }\n"
"\n"
"  foreign static def readStart_()\n"
"  foreign static def readStop_()\n"
"}\n";
