// Generated automatically from src/module/io.wren. Do not edit.
static const char* ioModuleSource =
"import \"scheduler\" for Scheduler\n"
"\n"
"foreign class File {\n"
"  static open(path) {\n"
"    if (!(path is String)) Fiber.abort(\"Path must be a string.\")\n"
"\n"
"    open_(path, Fiber.current)\n"
"    var fd = Scheduler.runNextScheduled_()\n"
"    return new_(fd)\n"
"  }\n"
"\n"
"  static open(path, fn) {\n"
"    var file = open(path)\n"
"    var fiber = Fiber.new { fn(file) }\n"
"\n"
"    // Poor man's finally. Can we make this more elegant?\n"
"    var result = fiber.try()\n"
"    file.close()\n"
"\n"
"    // TODO: Want something like rethrow since now the callstack ends here. :(\n"
"    if (fiber.error != null) Fiber.abort(fiber.error)\n"
"    return result\n"
"  }\n"
"\n"
"  static read(path) {\n"
"    return File.open(path) {|file| file.readBytes(file.size) }\n"
"  }\n"
"\n"
"  static size(path) {\n"
"    if (!(path is String)) Fiber.abort(\"Path must be a string.\")\n"
"\n"
"    sizePath_(path, Fiber.current)\n"
"    return Scheduler.runNextScheduled_()\n"
"  }\n"
"\n"
"  construct new_(fd) {}\n"
"\n"
"  close() {\n"
"    if (close_(Fiber.current)) return\n"
"    Scheduler.runNextScheduled_()\n"
"  }\n"
"\n"
"  isOpen { descriptor != -1 }\n"
"\n"
"  size {\n"
"    if (!isOpen) Fiber.abort(\"File is not open.\")\n"
"\n"
"    size_(Fiber.current)\n"
"    return Scheduler.runNextScheduled_()\n"
"  }\n"
"\n"
"  readBytes(count) {\n"
"    if (!isOpen) Fiber.abort(\"File is not open.\")\n"
"    if (!(count is Num)) Fiber.abort(\"Count must be an integer.\")\n"
"    if (!count.isInteger) Fiber.abort(\"Count must be an integer.\")\n"
"    if (count < 0) Fiber.abort(\"Count cannot be negative.\")\n"
"\n"
"    readBytes_(count, Fiber.current)\n"
"    return Scheduler.runNextScheduled_()\n"
"  }\n"
"\n"
"  foreign static open_(path, fiber)\n"
"  foreign static sizePath_(path, fiber)\n"
"\n"
"  foreign close_(fiber)\n"
"  foreign descriptor\n"
"  foreign readBytes_(count, fiber)\n"
"  foreign size_(fiber)\n"
"}\n"
"\n"
"class Stdin {\n"
"  static readLine() {\n"
"    if (__isClosed == true) {\n"
"      Fiber.abort(\"Stdin was closed.\")\n"
"    }\n"
"\n"
"    // TODO: Error if other fiber is already waiting.\n"
"    readStart_()\n"
"\n"
"    __waitingFiber = Fiber.current\n"
"    var line = Scheduler.runNextScheduled_()\n"
"\n"
"    readStop_()\n"
"    return line\n"
"  }\n"
"\n"
"  static onData_(data) {\n"
"    if (data == null) {\n"
"      __isClosed = true\n"
"      readStop_()\n"
"\n"
"      if (__line != null) {\n"
"        var line = __line\n"
"        __line = null\n"
"        if (__waitingFiber != null) __waitingFiber.transfer(line)\n"
"      } else {\n"
"        __waitingFiber.transferError(\"Stdin was closed.\")\n"
"      }\n"
"    }\n"
"\n"
"    // TODO: Handle Windows line separators.\n"
"    var lineSeparator = data.indexOf(\"\n\")\n"
"\n"
"    if (__line == null) __line = \"\"\n"
"    if (lineSeparator == -1) {\n"
"      // No end of line yet, so just accumulate it.\n"
"      __line = __line + data\n"
"    } else {\n"
"      // Split the line at the separator.\n"
"      var line = __line + data[0...lineSeparator]\n"
"      if (lineSeparator > 0 && lineSeparator < data.count - 1) {\n"
"        // Buffer up the characters after the separator for the next line.\n"
"        __line = data[lineSeparator + 1..-1]\n"
"      } else {\n"
"        __line = \"\"\n"
"      }\n"
"\n"
"      if (__waitingFiber != null) __waitingFiber.transfer(line)\n"
"    }\n"
"  }\n"
"\n"
"  foreign static readStart_()\n"
"  foreign static readStop_()\n"
"}\n";
